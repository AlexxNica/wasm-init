# **wasm-init**

## Work environment and template code for WebAssembly projects

### **Install**

wasm-init abstracts the WebAssembly setup and compile process and aims to dramatically simplify the development workflow.


This package requires that you have [**Emscripten**](https://github.com/juj/emsdk.git) installed on your machine. You can get like so:
```
git clone https://github.com/juj/emsdk.git
cd emsdk
./emsdk install sdk-incoming-64bit binaryen-master-64bit
./emsdk activate sdk-incoming-64bit binaryen-master-64bit
```
(Note, that the install will take a while. More information is [here](http://webassembly.org/getting-started/developers-guide/).)


The best way to install this module is via `npm install wasm-init`.


### **Use**

At the heart of wasm-init is the *wasm.config.js* file, which takes Emscripten's compile process and breaks it down into configurable elements. To compile C++ to WASM with Emscripten, you need at bare minimum the following properties:
```
// wasm.config.js
module.exports = {
  emscripten_path: './../emsdk',
  inputfiles: [
    'lib.cpp',
  ],
  outputfiles: [
    'lib.js',
  ],
  flags: [
    '-s WASM=1',
  ],
};
```
`emscripten_path` is the relative path to the *emsdk* directory, from your project folder. (In the above case, we would expect Emscripten to be located in the same parent-directory as the project.)


If you want to automate this process you can set up a few scripts in your project's *package.json* file: 
```
...
  "scripts": {
    "wasm-init": "wasm-init",
    "compile": "wasm-compile"
    "start": "gulp",   // optional
  }
...
  ```
These scripts make the module's functionality accessible. Be aware that `npm run wasm-init` **will create several files and folders inside your project directory.** This is your fastest route to a working project setup, however, you can also set up all the files manually, if you so desire.

To compile, simply use `npm run compile`, which will take your C++ code and output a JavaScript file with Emscripten bindings, as well as the sought after .wasm file. To take advantage of wasm-init's easy loading mechanism for WebAssembly modules, you will need wrapper file loadWASM.js. The wasm module is from there returned by a promise. Making the module accessible to your application is as easy as the following:
```
let m = {}
loadWASM().then(wasmModule => {
  m = wasmModule;
  m._myFunc();
});
```


If you are on board with wasm-init's automation, the quickest road to success would be:
`npm run wasm-init emcc_path=./../emsdk` (modify path accordingly). This will set Emscripten's file path in the wasm.config.js file automatically. This will also install and compile all necessary files, including a server.js, index.js and index.html file, that are already setup to include WASM in the browser. (Executing `npm run wasm-init` *will overwrite any files that may already be there!*)

If you want less clutter, the following flags for `npm run wasm-init` might be of interest: 

`minimal`     - only creates the wasm-wrapper (loadWASM.js) and wasm.config.js file

`no-cpp`      - no C++ file

`no-indexjs`  - no index.js file

`no-html`     - no html file

`no-server`   - no server.js file


If you want built-in **hot reloading** functionality, via **gulp** and **browser-sync**, just add the flag `hot`. Note, that this will install the gulp and browser-sync packages automatically. This will also generate a gulpfile.js file, which is already setup to work with the template code.


Lastly,

`npm run wasm-init clean`

will **delete all of the autogenerated files**. Please use it carefully!

